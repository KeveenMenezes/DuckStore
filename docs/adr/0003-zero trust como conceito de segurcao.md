# ADR-0003: Adoption of Zero Trust Security Model

## Status
**Proposed** â€” February 2026  

---

## Context

The DuckStore application is a distributed microservices-based system deployed in a public cloud environment.  

Challenges:

- Publicly exposed services increase attack surface.  
- Internal communication between services must **not implicitly trust the network**.  
- Users authenticate via Cognito and perform actions across multiple services (bounded contexts).  
- Some interactions are synchronous (request/response), others asynchronous (event-driven).  
- Microservices need independent **identity validation** for both user and service calls.  
- Asynchronous messages may contain sensitive claims that require **encryption at rest and in transit**.

---

## Decision

Adopt **Zero Trust Security Model** with Cloud Native Security principles:

- **Every request is authenticated and authorized**, regardless of origin.  
- **Services validate JWT tokens independently**, including internal service-to-service calls.  
- **Service identities** (machine-to-machine) use **Client Credentials Flow** via Cognito.  
- **Authorization is policy-based** within each service.  
- **Identity propagation preserves cryptographic integrity**.  
- **Communication channels are encrypted and secured**:  
  - **Synchronous:** HTTPS/TLS for API calls.  
  - **Asynchronous:** SQS/RabbitMQ with **Envelope Encryption using AWS KMS** and JWT claim validation.  
- **Service-to-Service access** uses least privilege: services only have scopes required for the specific action.  
- **Observability:** Logs, telemetry, and audit trails for all access attempts.  

**KMS Envelope Encryption** ensures that:

- Each asynchronous message payload is encrypted with a **data key** generated by KMS.  
- Only the intended consuming service can decrypt the data key and then the payload.  
- Reduces risk of sensitive claim exposure in transit or at rest.  
- Supports high-volume messaging with short-lived JWTs for Zero Trust compliance.

---

## Example Flow: User login triggering Service A â†’ Service B

### 1ï¸âƒ£ User Authentication

1. User authenticates via **Cognito** â†’ receives **User JWT token**.

### 2ï¸âƒ£ User â†’ Service A (via API Gateway)

1. User sends request with JWT to **API Gateway (HTTPS)**.  
2. API Gateway validates:
   - JWT signature  
   - Token expiration  
   - Required scopes  
3. API Gateway forwards request to **Service A** with JWT.  
4. Service A independently validates JWT and maps claims to internal user context.

### 3ï¸âƒ£ Service A â†’ Service B (Internal Call)

#### ðŸ”¹ Synchronous

1. Service A requests a **Service Token** via Cognito using **Client Credentials Flow**.  
2. Service A calls Service B via **HTTPS**, including the Service JWT.  
3. Service B validates:
   - JWT signature and expiration  
   - Issuer and client identity  
   - Required scopes/policies  
4. Service B processes request and returns response to Service A.

#### ðŸ”¹ Asynchronous (SQS/RabbitMQ + KMS Envelope)

1. Service A publishes an event to **SQS/RabbitMQ**.  
2. Event payload includes:
   - JWT claims **encrypted using KMS Envelope Encryption**  
   - Action metadata  
3. Service B consumes the event:
   - Decrypts the data key via KMS  
   - Decrypts the payload locally  
   - Validates claims and applies policies before processing

---

## Sequence Diagram (Mermaid)

```mermaid
sequenceDiagram
    participant User
    participant Cognito
    participant API_Gateway
    participant Service_A
    participant Service_B
    participant SQS
    participant KMS

    User->>Cognito: Authenticate (username/password)
    Cognito-->>User: JWT Token (User)

    User->>API_Gateway: Request with User JWT
    API_Gateway->>API_Gateway: Validate User JWT
    API_Gateway->>Service_A: Forward request with JWT

    Service_A->>Service_A: Validate JWT, map claims

    %% Synchronous Service-to-Service
    Service_A->>Cognito: Request Service Token (Client Credentials)
    Cognito-->>Service_A: JWT Token (Service)
    Service_A->>Service_B: HTTPS call with Service JWT
    Service_B->>Service_B: Validate Service JWT, apply policies
    Service_B-->>Service_A: Response

    %% Asynchronous Event with KMS Envelope Encryption
    Service_A->>KMS: Generate Data Key
    KMS-->>Service_A: Return Data Key (encrypted)
    Service_A->>SQS: Publish event with encrypted claims
    Service_B->>SQS: Consume event
    Service_B->>KMS: Decrypt Data Key
    KMS-->>Service_B: Return Data Key (plaintext)
    Service_B->>Service_B: Decrypt payload, validate claims, apply policies